* dinero
A Clojure library for working with money.
** Table of contents                                                  :TOC_3:
- [[#dinero][dinero]]
  - [[#configuration][Configuration]]
  - [[#usage][Usage]]
    - [[#monetary-amounts][Monetary amounts]]
    - [[#formatting][Formatting]]
    - [[#parsing][Parsing]]
    - [[#equality-and-comparison][Equality and comparison]]
    - [[#arithmetic-operations][Arithmetic operations]]
    - [[#rounding][Rounding]]
  - [[#license][License]]

** Configuration
For convenience, before using this library, you can configure the variables =default-currency= and =default-rounding-mode= in a configuration file named =config.edn=, which should be located in the root directory of the project.

For example, to set /euros/ as the default currency and the /half even/ method as the default rounding method, the =config.edn= file should have the following content:
#+begin_src clojure
  {:default-currency :eur
   :default-rounding-mode :half-even}
#+end_src
** Usage
You can try out the examples below in a REPL after the following =require=:
#+begin_src clojure
  (require '[dinero.core :as dinero])
#+end_src
*** Monetary amounts
This library support two types of monetary amounts:
- =money=: represents monetary amounts with arbitrary precision and scale, ensuring accurate numerical computations during arithmetic operations.
- =rounded money=: represents monetary amounts that are automatically rounded after each arithmetic operation.
**** Creating monetary amounts of type =money=
You can use =money-of= to create monetary amounts with arbitrary precision and scale. It accepts two arguments:
- =amount=: can be either an integer, a floating-point number, a =BigDecimal= or a string.
- =currency=: must be a keyword.
If the =currency= is not specified, the =money-of= function will use the default currency set in the configuration file. If a currency is provided, it will override the default and use the specified currency instead:
#+begin_src clojure
  (dinero/money-of 1)
  ;; => {:amount 1M, :currency :eur}

  (dinero/money-of 1 :gbp)
  ;; => {:amount 1M, :currency :gbp}
#+end_src
For convenience, you can use the =with-currency= macro to bind the =*default-currency*= variable. This way, if the variable isn’t set in the configuration file, you won’t need to specify the currency when creating monetary amounts:
#+begin_src clojure
  (dinero/with-currency :gbp
    (dinero/money-of 1))
  ;; => {:amount 1M, :currency :gbp}
#+end_src
If none the =amount= nor the =currency= is specified, it uses zero as the amount, and the default currency as the currency:
#+begin_src clojure
  (dinero/money-of)
  ;; => {:amount 0M, :currency :eur}
#+end_src
Although you can use either an integer, a floating-point number, a =BigDecimal= or a string as the =amount= argument, they are parsed and stored as =BigDecimals=:
#+begin_src clojure
  (dinero/money-of 1 :eur)
  ;; => {:amount 1M, :currency :eur}

  (dinero/money-of 1.23 :eur)
  ;; => {:amount 1.23M, :currency :eur}

  (dinero/money-of 1.23M :eur)
  ;; => {:amount 1.23M, :currency :eur}

  (dinero/money-of "1.23" :eur)
  ;; => {:amount 1.23M, :currency :eur}
#+end_src
/WARNING/:
#+begin_quote
Be aware that using floating-point numbers can lead to rounding errors in certain calculations, as Clojure reads them as =Doubles=, which are 64-bit IEEE 754 floating point numbers. This means you get double precision, with about 15-17 significant decimal digits of precision.

So, for accurate numerical computations, especially in financial applications, don't use floating-point numbers; use =BigDecimals= or =Strings= instead, as they will be parsed accurately.
#+begin_src clojure
  ;;; Not safe, as it uses a floating-point number, losing precision when parsing
  (dinero/money-of 0.123456789123456789123456789 :eur)
  ;; => {:amount 0.12345678912345678M, :currency :eur}

  ;;; Safe, as it uses BigDecimal or String
  (dinero/money-of 0.123456789123456789123456789M :eur)
  ;; => {:amount 0.123456789123456789123456789M, :currency :eur}
  (dinero/money-of "0.123456789123456789123456789" :eur)
  ;; => {:amount 0.123456789123456789123456789M, :currency :eur}
#+end_src
#+end_quote
**** Creating monetary amounts of type =rounded-money=
You can use =rounded-money-of= to create monetary amounts that are automatically rounded after each arithmetic operation. It accepts up to 4 arguments:
- =amount=: can be an integer, a floating-point number, a =BigDecimal= or a string.
- =currency=: must be a keyword.
- =scale=: the number of decimal places to which the amount will be rounded.
- =rounding-mode=: the rounding mode to use when rounding the amount.
If =currency= is not specified, the =rounded-money-of= function will use the default currency from the configuration file. If =scale= is not provided, the minor units of the given currency will be used. If =rounding-mode= is not specified, the default rounding mode will be applied (or =:half-even= if the default rounding mode is not set in the configuration file):
#+begin_src clojure
  (dinero/rounded-money-of 1234.5678 :eur)
  ;; => {:amount 1234.57M, :currency :eur, :scale 2, :rounding-mode :half-even}

  (dinero/rounded-money-of 1234.5678 :eur 0)
    ;; => {:amount 1235M, :currency :eur, :scale 0, :rounding-mode :half-even}

  (dinero/rounded-money-of 1234.5678 :eur 0 :down)
  ;; => {:amount 1234M, :currency :eur, :scale 0, :rounding-mode :down}
#+end_src
**** Getting the amount, currency, and rounding information
Given a monetary amount, you can get its amount and currency using the =get-amount= and =get-currency= functions:
#+begin_src clojure
  (let [money (dinero/money-of 1 :eur)]
    (dinero/get-amount money))
  ;; => 1M
  (let [money (dinero/money-of 1 :eur)]
    (dinero/get-currency money))
  ;; => :eur
#+end_src
For rounded monetary amounts, you can also use the =get-scale= and =get-rounding-mode= functions to retrieve the scale and rounding mode applied during the rounding process:
#+begin_src clojure
  (let [money (dinero/rounded-money-of 1 :eur)]
    (dinero/get-scale money))
  ;; => 2

  (let [money (dinero/rounded-money-of 1 :eur)]
    (dinero/get-rounding-mode money))
  ;; => :half-even
#+end_src
*** Formatting
As already mentioned, monetary amounts could be stored internally with more decimal places than the smallest unit of the currency. Although this may be important for accurate numerical computations, you might be interested in displaying amounts in a user-friendly format.

To display monetary amounts in a user-friendly format, you can use the =format= function. This function will convert the internal representation of the monetary amount into a string with a more readable format.

The =format= function accepts a map of configuration options as its second argument. The available options are:
- locale
- rounding-mode
- decimal-places
- symbol-style: could be =:symbol= or =:code= (=:symbol= is the default value)
For example:
#+begin_src clojure
  (let [m1 (dinero/money-of 1234.5678 :eur)
        germany java.util.Locale/GERMANY]
    (println (dinero/format m1 {:locale germany}))
    (println (dinero/format m1 {:locale germany :symbol-style :code}))
    (println (dinero/format m1 {:locale germany :rounding-mode :down :symbol-style :code}))
    (println (dinero/format m1 {:locale germany :rounding-mode :down :decimal-places 0 :symbol-style :code})))
  ;; 1.234,57 €
  ;; 1.234,57 EUR
  ;; 1.234,56 EUR
  ;; 1.234 EUR
#+end_src
You can also use the =format-with-pattern= function, which uses the given formatting pattern to format the monetary amount. This function also accepts a map of configuration options as its third argument, supporting these options:
- locale
- rounding-mode
For example:
#+begin_src clojure
  (let [m1 (dinero/money-of 1234.5678 :eur)
        germany java.util.Locale/GERMANY]
    (println (dinero/format-with-pattern m1 "#,##0.00 ¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0.00 ¤¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0.000 ¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0 ¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0 ¤" {:locale germany :rounding-mode :down})))
  ;; 1.234,57 €
  ;; 1.234,57 EUR
  ;; 1.234,568 €
  ;; 1.235 €
  ;; 1.234 €
#+end_src
*** Parsing
For now, this library only supports parsing strings that contain ISO 4217 currency symbols (like =€=) but does not support parsing strings with ISO 4217 currency codes (like =EUR=) or strings with non-ISO 4217 currency symbols or codes (like =₿= or =BTC=).

So you can use the =parse-containing-iso-4217-symbol= function to parse a string that contains an ISO 4217 currency symbol:
#+begin_src clojure
  (dinero/parse-containing-iso-4217-symbol "1.234,56 €" java.util.Locale/GERMANY)
  ;; => {:amount 1234.56M, :currency :eur}

  (dinero/parse-containing-iso-4217-symbol "£1,234.56" java.util.Locale/UK)
  ;; => {:amount 1234.56M, :currency :gbp}
#+end_src
But as mentioned, it doesn't support parsing strings with ISO 4217 currency codes or strings with non-ISO 4217 currency symbols or codes, throwing a =java.text.ParseException= exception in that case:
#+begin_src clojure
  (dinero/parse-containing-iso-4217-symbol "1.234,56 EUR" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "1.234,56 EUR"

  (dinero/parse-containing-iso-4217-symbol "1,23456789 ₿" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "1,23456789 ₿"

  (dinero/parse-containing-iso-4217-symbol "1,23456789 BTC" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "1,23456789 BTC"
#+end_src
The =parse-containing-iso-4217-symbol= function also throws a =java.text.ParseException= exception if the currency symbol is in the wrong position for the specified =locale=, or if the =locale= uses a different default currency:
#+begin_src clojure
  (dinero/parse-containing-iso-4217-symbol "€1.234,56" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "€1.234,56"

  (dinero/parse-containing-iso-4217-symbol "1.234,56 £" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "1.234,56 £"
#+end_src
*** Equality and comparison
You could use the following functions to do equality and comparison operations on monetary amounts: ~money=~, =money-not==, =money<=, =money<==, =money>=, =money>==, =money-zero?=, =monmey-pos?=, and =money-neg?=.

For example:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :eur)]
    (dinero/money= m1 m2))
  ;; => true

  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 2 :eur)]
    (dinero/money-not= m1 m2))
  ;; => true

  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 2 :eur)]
    (dinero/money< m1 m2))
  ;; => true

  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 2 :eur)]
    (dinero/money> m1 m2))
  ;; => false

  (let [money (dinero/money-of 0 :eur)]
    (dinero/money-zero? money))
  ;; => true

  (let [money (dinero/money-of -1 :eur)]
    (dinero/money-pos? money))
  ;; => false

  (let [money (dinero/money-of -1 :eur)]
    (dinero/money-neg? money))
  ;; => true
#+end_src
When these operations involve more than one monetary amount, they throw an =ExceptionInfo= exception if currencies don't match:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :gbp)]
    (dinero/money= m1 m2))
  ;; clojure.lang.ExceptionInfo
  ;; Currencies do not match
  ;; {:currencies (:eur :gbp)}
#+end_src
*** Arithmetic operations
You can use =add=, =substract=, =multiply=, and =divide= to perform arithmetic operations on monetary amounts:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :eur)]
    (dinero/add m1 m2))
  ;; => {:amount 2M, :currency :eur}

  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :eur)]
    (dinero/subtract m1 m2))
  ;; => {:amount 0M, :currency :eur}

  (let [money (dinero/money-of 1 :eur)
        factor 2]
    (dinero/multiply money factor))
  ;; => {:amount 2M, :currency :eur}

  (let [money (dinero/money-of 2 :eur)
        divisor 2]
    (dinero/divide money divisor))
  ;; => {:amount 1M, :currency :eur}
#+end_src
Note that =add= and =substract= can be used to add and substract more than two monetary amounts:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 2 :eur)
        m3 (dinero/money-of 3 :eur)]
    (dinero/add m1 m2 m3))
  ;; => {:amount 6M, :currency :eur}

  (let [m1 (dinero/money-of 3 :eur)
        m2 (dinero/money-of 2 :eur)
        m3 (dinero/money-of 1 :eur)]
    (dinero/subtract m1 m2 m3))
  ;; => {:amount 0M, :currency :eur}
#+end_src
Adding or substracting monetary amounts with different currencies throws an =ExceptionInfo= exception:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :gbp)]
    (dinero/add m1 m2))
  ;; clojure.lang.ExceptionInfo
  ;; Currencies do not match
  ;; {:currencies (:eur :gbp)}
#+end_src
*** Rounding
As previously mentioned, money amounts could be stored internally with more decimal places than the smallest unit of the currency. But some applications might require operating with amounts rounded to the smallest unit of currency. In such cases, you can use the =round= function to adjust the monetary amounts accordingly.

By default, the =round= function rounds amounts to the smallest unit of the currency, using the default rounding mode specified in the configuration file (if no rounding mode is configured, it defaults to =:half-even=):
#+begin_src clojure
  (let [m1 (dinero/money-of 1.555 :eur)
        m2 (dinero/money-of 1.555 :eur)]
    (dinero/add m1 m2))
  ;; => {:amount 3.110M, :currency :eur}

  (let [m1 (dinero/money-of 1.555 :eur)
        m2 (dinero/money-of 1.555 :eur)
        m1-rounded (dinero/round m1)
        m2-rounded (dinero/round m2)]
    (dinero/add m1-rounded m2-rounded))
  ;; => {:amount 3.12M, :currency :eur}
#+end_src
But you can also speficy the number of decimal places and the rounding mode you want to use when rounding. For example:
#+begin_src clojure
  (let [m1 (dinero/money-of 1.555 :eur)
        m2 (dinero/money-of 1.555 :eur)
        m1-rounded (dinero/round m1 0 :half-even)
        m2-rounded (dinero/round m2 0 :half-even)]
    (dinero/add m1-rounded m2-rounded))
  ;; => {:amount 4M, :currency :eur}
#+end_src
If necessary, you can also call =round= with two arguments, which are the monetary amount and a custom rounding funtion to use to round the monetary amount. This allows you to specify different rounding rules for certain cases.

For example, the Swiss Franc (=CHF=) uses unique rounding rules because the smallest unit of currency in Switzerland is the 5-centime (=0.05 CHF=) coin. To handle the specific rounding requirements for Swiss Francs, you can use the =chf-rounding-fn= function, which containins a rounding function tailored to =CHF=:
#+begin_src clojure
  (let [money (dinero/money-of 1.024 :chf)]
    (dinero/round money dinero/chf-rounding-fn))
  ;; => {:amount 1.00M, :currency :chf}

  (let [money (dinero/money-of 1.025 :chf)]
    (dinero/round money dinero/chf-rounding-fn))
  ;; => {:amount 1.05M, :currency :chf}
#+end_src
This approach is also useful when formatting currencies with special rounding requirements. For instance, when formatting Swiss Francs, you might want to round the amount before using the =format= function to ensure the displayed value matches the currency's rounding conventions:
#+begin_src clojure
  (let [money (dinero/money-of 1.025 :chf)]
    (dinero/format money {:locale (java.util.Locale. "de" "CH")}))
  ;; => "CHF 1.02"

  (let [money (dinero/money-of 1.025 :chf)
        rounded-money (dinero/round money dinero/chf-rounding-fn)]
    (dinero/format rounded-money {:locale (java.util.Locale. "de" "CH")}))
  ;; => "CHF 1.05"
#+end_src
** License
Copyright © 2024 Sergio Navarro

Distributed under the [[https://www.apache.org/licenses/LICENSE-2.0][Apache License, Version 2.0]].
