* dinero
A Clojure library for working with money.
** Table of contents                                                  :TOC_3:
- [[#dinero][dinero]]
  - [[#configuration][Configuration]]
  - [[#usage][Usage]]
    - [[#monetary-amounts][Monetary amounts]]
    - [[#formatting][Formatting]]
    - [[#parsing][Parsing]]
    - [[#equality-and-comparison][Equality and comparison]]
    - [[#arithmetic-operations][Arithmetic operations]]
    - [[#rounding][Rounding]]
  - [[#license][License]]

** Configuration
Before using this library, you can configure the variables =default-currency= and =default-rounding-mode= in a configuration file named =config.edn=, that should be located in the root directory of the project.

For example, for using /euros/ as the default currency, and the /half even/ method as the default rounding method, the content of the =config.edn= file should be:
#+begin_src clojure
  {:default-currency :eur
   :default-rounding-mode :half-even}
#+end_src
** Usage
You can try out the examples below in a REPL after the following =require=:
#+begin_src clojure
  (require '[dinero.core :as dinero])
#+end_src
*** Monetary amounts
This library support two types of monetary amounts:
- =money=: represents monetary amounts with arbitrary precision and scale, ensuring accurate numerical computations during arithmetic operations.
- =rounded money=: represents monetary amounts that are automatically rounded after each arithmetic operation.
**** Creating monetary amounts of type =money=
You can use =money-of= to create monetary amounts with arbitrary precision and scale. It accepts two arguments:
- =amount=: can be either an integer, a floating-point number, a =BigDecimal= or a string.
- =currency=: must be a keyword.
If the =currency= is not specified, it uses the default currency configured in the configuration file. Otherwise, it uses the given currency:
#+begin_src clojure
  (dinero/money-of 1)
  ;; => {:amount 1M, :currency :eur}

  (dinero/money-of 1 :gbp)
  ;; => {:amount 1M, :currency :gbp}
#+end_src
For convenience, you can use the =with-currency= macro to bind the =*default-currency*= variable, so if that variable isn't configured in the configuration file, you don't need to specify the currency when creating a monetary amount:
#+begin_src clojure
  (dinero/with-currency :gbp
    (dinero/money-of 1))
  ;; => {:amount 1M, :currency :gbp}
#+end_src
If none the =amount= nor the =currency= is specified, it uses zero as the amount, and the default currency as the currency:
#+begin_src clojure
  (dinero/money-of)
  ;; => {:amount 0M, :currency :eur}
#+end_src
Although you can use either an integer, a floating-point number, a =BigDecimal= or a string as the =amount= argument, they are parsed and stored as =BigDecimals=:
#+begin_src clojure
  (dinero/money-of 1 :eur)
  ;; => {:amount 1M, :currency :eur}

  (dinero/money-of 1.23 :eur)
  ;; => {:amount 1.23M, :currency :eur}

  (dinero/money-of 1.23M :eur)
  ;; => {:amount 1.23M, :currency :eur}

  (dinero/money-of "1.23" :eur)
  ;; => {:amount 1.23M, :currency :eur}
#+end_src
/WARNING/:
#+begin_quote
Be aware that using floating-point numbers can lead to rounding errors in certain calculations, as Clojure reads them as =Doubles=, which are 64-bit IEEE 754 floating point numbers. This means you get double precision, with about 15-17 significant decimal digits of precision.

So, for accurate numerical computations, especially in financial applications, don't use floating-point numbers; use =BigDecimals= or =Strings= instead, as they will be parsed accurately.
#+begin_src clojure
  ;;; Not safe, as it uses floating-point number, losing precision when parsing
  (dinero/money-of 0.123456789123456789123456789 :eur)
  ;; => {:amount 0.12345678912345678M, :currency :eur}

  ;;; Safe, as it uses BigDecimal or String
  (dinero/money-of 0.123456789123456789123456789M :eur)
  ;; => {:amount 0.123456789123456789123456789M, :currency :eur}
  (dinero/money-of "0.123456789123456789123456789" :eur)
  ;; => {:amount 0.123456789123456789123456789M, :currency :eur}
#+end_src
#+end_quote
**** Creating monetary amounts of type =rounded-money=
You can use =rounded-money-of= to create monetary amounts that are automatically rounded after each arithmetic operation. It could accept up to 4 arguments:
- =amount=: can be an integer, a floating-point number, a =BigDecimal= or a string.
- =currency=: must be a keyword.
- =scale=: the number of decimal places to which the amount will be rounded.
- =rounding-mode=: the rounding mode to use when rounding the amount.
If the =currency= is not specified, the default currency configured in the configuration file will be used. If the =scale= is not specified, the minor units of the given currency will be used. If the =rounding-mode= is not specified, the default rounding mode (or /half even/ mode) will be applied:
#+begin_src clojure
  (dinero/rounded-money-of 1234.5678 :eur)
  ;; => {:amount 1234.57M, :currency :eur, :rounding-context {:scale 2, :rounding-mode :half-even}}

  (dinero/rounded-money-of 1234.5678 :eur 2 :down)
  ;; => {:amount 1234.56M, :currency :eur, :rounding-context {:scale 2, :rounding-mode :down}}

  (dinero/rounded-money-of 1234.5678 :eur 0 :down)
  ;; => {:amount 1234M, :currency :eur, :rounding-context {:scale 0, :rounding-mode :down}}
#+end_src
As mentioned, =rounded-money-of= is a variadic function, so you might find it useful to use its 3-parameter version and pass a map specifying the =scale= and =rounding-mode=:
#+begin_src clojure
  (dinero/rounded-money-of 1234.5678 :eur)
  ;; => {:amount 1234.57M, :currency :eur, :rounding-context {:scale 2, :rounding-mode :half-even}}

  (dinero/rounded-money-of 1234.5678 :eur {:rounding-mode :down})
  ;; => {:amount 1234.56M, :currency :eur, :rounding-context {:scale 2, :rounding-mode :down}}

  (dinero/rounded-money-of 1234.5678 :eur {:scale 0 :rounding-mode :down})
  ;; => {:amount 1234M, :currency :eur, :rounding-context {:scale 0, :rounding-mode :down}}
#+end_src
**** Getting the amount and currency of a monetary amount
Given a monetary amount, you can get its amount and currency using the =get-amount= and =get-currency= functions:
#+begin_src clojure
  (let [money (dinero/money-of 1 :eur)]
    (dinero/get-amount money))
  ;; => 1M
  (let [money (dinero/money-of 1 :eur)]
    (dinero/get-currency money))
  ;; => :eur
#+end_src
For rounded monetary amounts you can also use the =get-rounding-context= function to get the rounding context used for rounding its amount:
#+begin_src clojure
  (let [money (dinero/rounded-money-of 123.456 :eur {:scale 2 :rounding-context :half-even})]
    (dinero/get-rounding-context money))
  ;; => {:scale 2, :rounding-context :half-even}
#+end_src
*** Formatting
As already mentioned, amounts are stored internally with more decimal places than the smallest unit of the currency. Although this is crucial for accurate numerical computations, you might be interested in displaying amounts in a user-friendly format.

To display monetary amounts in a user-friendly format, you can use the =format= function. This function will convert the internal representation of the monetary amount into a string with a more readable format.

The =format= function accepts a map of configuration options as its second argument. The available options are:
- locale
- rounding-mode
- decimal-places
- symbol-style: could be =:symbol= or =:code= (=:symbol= is the default value)
For example:
#+begin_src clojure
  (let [m1 (dinero/money-of 1234.5678 :eur)
        germany java.util.Locale/GERMANY]
    (println (dinero/format m1 {:locale germany}))
    (println (dinero/format m1 {:locale germany :symbol-style :code}))
    (println (dinero/format m1 {:locale germany :rounding-mode :down :symbol-style :code}))
    (println (dinero/format m1 {:locale germany :rounding-mode :down :decimal-places 0 :symbol-style :code})))
  ;; 1.234,57 €
  ;; 1.234,57 EUR
  ;; 1.234,56 EUR
  ;; 1.234 EUR
#+end_src
You can also use the =format-with-pattern= function, which uses the given formatting pattern to format the monetary amount. This function also accepts a map of configuration options as its third argument, supporting these options:
- locale
- rounding-mode
For example:
#+begin_src clojure
  (let [m1 (dinero/money-of 1234.5678 :eur)
        germany java.util.Locale/GERMANY]
    (println (dinero/format-with-pattern m1 "#,##0.00 ¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0.00 ¤¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0.000 ¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0 ¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0 ¤" {:locale germany :rounding-mode :down})))
  ;; 1.234,57 €
  ;; 1.234,57 EUR
  ;; 1.234,568 €
  ;; 1.235 €
  ;; 1.234 €
#+end_src
*** Parsing
For now, this library only supports parsing strings that contain ISO 4217 currency symbols (like =€=) but does not support parsing strings with ISO 4217 currency codes (like =EUR=) or strings with non-ISO 4217 currency symbols or codes (like =₿= or =BTC=).

So you can use the =parse-containing-iso-4217-symbol= function to parse a string that contains an ISO 4217 currency symbol:
#+begin_src clojure
  (dinero/parse-containing-iso-4217-symbol "1.234,56 €" java.util.Locale/GERMANY)
  ;; => {:amount 1234.56M, :currency :eur}

  (dinero/parse-containing-iso-4217-symbol "£1,234.56" java.util.Locale/UK)
  ;; => {:amount 1234.56M, :currency :gbp}
#+end_src
But as mentioned, it doesn't support parsing strings with ISO 4217 currency codes or strings with non-ISO 4217 currency symbols or codes, throwing a =java.text.ParseException= exception in that case:
#+begin_src clojure
  (dinero/parse-containing-iso-4217-symbol "1.234,56 EUR" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "1.234,56 EUR"

  (dinero/parse-containing-iso-4217-symbol "1,23456789 ₿" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "1,23456789 ₿"

  (dinero/parse-containing-iso-4217-symbol "1,23456789 BTC" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "1,23456789 BTC"
#+end_src
The =parse-containing-iso-4217-symbol= function also throws a =java.text.ParseException= exception if the currency symbol is in the wrong position for the specified =locale=, or if the =locale= uses a different default currency:
#+begin_src clojure
  (dinero/parse-containing-iso-4217-symbol "€1.234,56" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "€1.234,56"

  (dinero/parse-containing-iso-4217-symbol "1.234,56 £" java.util.Locale/GERMANY)
  ;; java.text.ParseException
  ;; Unparseable number: "1.234,56 £"
#+end_src
*** Equality and comparison
You could use the following functions to do equality and comparison operations on monetary amounts: ~money=~, =money-not==, =money<=, =money<==, =money>=, =money>==, =money-zero?=, =monmey-pos?=, and =money-neg?=.

For example:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :eur)]
    (dinero/money= m1 m2))
  ;; => true

  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 2 :eur)]
    (dinero/money-not= m1 m2))
  ;; => true

  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 2 :eur)]
    (dinero/money< m1 m2))
  ;; => true

  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 2 :eur)]
    (dinero/money> m1 m2))
  ;; => false

  (let [money (dinero/money-of 0 :eur)]
    (dinero/money-zero? money))
  ;; => true

  (let [money (dinero/money-of -1 :eur)]
    (dinero/money-pos? money))
  ;; => false

  (let [money (dinero/money-of -1 :eur)]
    (dinero/money-neg? money))
  ;; => true
#+end_src
When these operations involve more than one monetary amount, they throw an =ExceptionInfo= exception if currencies don't match:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :gbp)]
    (dinero/money= m1 m2))
  ;; clojure.lang.ExceptionInfo
  ;; Currencies do not match
  ;; {:currencies (:eur :gbp)}
#+end_src
*** Arithmetic operations
You can use =add=, =substract=, =multiply=, and =divide= to perform arithmetic operations on monetary amounts:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :eur)]
    (dinero/add m1 m2))
  ;; => {:amount 2M, :currency :eur}

  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :eur)]
    (dinero/subtract m1 m2))
  ;; => {:amount 0M, :currency :eur}

  (let [money (dinero/money-of 1 :eur)
        factor 2]
    (dinero/multiply money factor))
  ;; => {:amount 2M, :currency :eur}

  (let [money (dinero/money-of 2 :eur)
        divisor 2]
    (dinero/divide money divisor))
  ;; => {:amount 1M, :currency :eur}
#+end_src
Note that =add= and =substract= can be used to add and substract more than two monetary amounts:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 2 :eur)
        m3 (dinero/money-of 3 :eur)]
    (dinero/add m1 m2 m3))
  ;; => {:amount 6M, :currency :eur}

  (let [m1 (dinero/money-of 3 :eur)
        m2 (dinero/money-of 2 :eur)
        m3 (dinero/money-of 1 :eur)]
    (dinero/subtract m1 m2 m3))
  ;; => {:amount 0M, :currency :eur}
#+end_src
Adding or substracting monetary amounts with different currencies throws an =ExceptionInfo= exception:
#+begin_src clojure
  (let [m1 (dinero/money-of 1 :eur)
        m2 (dinero/money-of 1 :gbp)]
    (dinero/add m1 m2))
  ;; clojure.lang.ExceptionInfo
  ;; Currencies do not match
  ;; {:currencies (:eur :gbp)}
#+end_src
*** Rounding
As previously mentioned, amounts are stored internally with more decimal places than the smallest unit of the currency. Although this is crucial for accurate numerical computations, some applications might require operations with amounts rounded to the smallest unit of currency. In such cases, you can use the =round= function to adjust the monetary amounts accordingly.

By default, the =round= function rounds amounts to the smallest unit of the currency, using the default rounding mode specified in the configuration file (if no rounding mode is configured, it defaults to =:half-even=):
#+begin_src clojure
  (let [m1 (dinero/money-of 1.555 :eur)
        m2 (dinero/money-of 1.555 :eur)]
    (dinero/add m1 m2))
  ;; => {:amount 3.110M, :currency :eur}

  (let [m1 (dinero/money-of 1.555 :eur)
        m2 (dinero/money-of 1.555 :eur)
        m1-rounded (dinero/round m1)
        m2-rounded (dinero/round m2)]
    (dinero/add m1-rounded m2-rounded))
  ;; => {:amount 3.12M, :currency :eur}
#+end_src
The =round= function also accepts an optional second argument, which is a custom rounding function. This allows you to specify different rounding rules for certain cases.

For example, the Japanese Yen (=JPY=) does not use any decimal places because it does not have a smaller denomination like cents. To handle this, you can use the =create-rounding= function with =0= as the argument, indicating that =JPY= amounts should be rounded to =0= decimal places:
#+begin_src clojure
  (let [m1 (dinero/money-of 1.555 :jpy)
        m2 (dinero/money-of 1.555 :jpy)]
    (dinero/add m1 m2))
  ;; => {:amount 3.110M, :currency :jpy}

  (let [m1 (dinero/money-of 1.555 :jpy)
        m2 (dinero/money-of 1.555 :jpy)
        rounding (dinero/create-rounding 0)
        m1-rounded (dinero/round m1 rounding)
        m2-rounded (dinero/round m2 rounding)]
    (dinero/add m1-rounded m2-rounded))
  ;; => {:amount 4M, :currency :jpy}
#+end_src
Another use case of custom rounding is the Swiss Franc (=CHF=), which uses unique rounding rules because the smallest unit of currency in Switzerland is the 5-centime (=0.05 CHF=) coin. To handle the specific rounding requirements for Swiss Francs, you can use the =chf-rounding= function, which creates a rounding function tailored to =CHF=:
#+begin_src clojure
  (let [money (dinero/money-of 1.024 :chf)
        rounding (dinero/chf-rounding)]
    (dinero/round money rounding))
  ;; => {:amount 1.00M, :currency :chf}

  (let [money (dinero/money-of 1.025 :chf)
        rounding (dinero/chf-rounding)]
    (dinero/round money rounding))
  ;; => {:amount 1.05M, :currency :chf}
#+end_src
This approach is also useful when formatting currencies with special rounding requirements. For instance, when formatting Swiss Francs, you might want to round the amount before using the =format= function to ensure the displayed value matches the currency's rounding conventions:
#+begin_src clojure
  (let [money (dinero/money-of 1.025 :chf)
        rounding (dinero/chf-rounding)]
    (dinero/format money {:locale (java.util.Locale. "de" "CH")}))
  ;; => "CHF 1.02"

  (let [money (dinero/money-of 1.025 :chf)
        rounding (dinero/chf-rounding)
        rounded-money (dinero/round money rounding)]
    (dinero/format rounded-money {:locale (java.util.Locale. "de" "CH")}))
  ;; => "CHF 1.05"
#+end_src
** License
Copyright © 2024 Sergio Navarro

Distributed under the [[https://www.apache.org/licenses/LICENSE-2.0][Apache License, Version 2.0]].
