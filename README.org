* dinero
A Clojure library for working with money
** Table of contents                                                  :TOC_3:
- [[#dinero][dinero]]
  - [[#configuration][Configuration]]
  - [[#usage][Usage]]
    - [[#create-monetary-amounts][Create monetary amounts]]
    - [[#amount-and-currency][Amount and currency]]
    - [[#formatting][Formatting]]
    - [[#parsing][Parsing]]
  - [[#license][License]]

** Configuration
Before using this library, you can configure the variables =default-currency= and =default-rounding-mode= in a configuration file named =config.edn=, that should be located in the root directory of the project.

For example, for using /euros/ as the default currency, and the /half even/ method as the default rounding method, the content of the =config.edn= file should be:
#+begin_src clojure
  {:default-currency :eur
   :default-rounding-mode :half-even}
#+end_src
** Usage
You can try out the examples below in a REPL after the following =require=:
#+begin_src clojure
  (require '[dinero.core :as dinero])
#+end_src
*** Create monetary amounts
Use =money-of= to create monetary amounts. It accepts two arguments:
- =amount=, that can be either an integer, a floating-point number, a =BigDecimal= or a string.
- =currency=, that must be a keyword.
If the =currency= is not specified, it uses the default currency configured in the configuration file. Otherwise, it uses the given currency:
#+begin_src clojure
  (dinero/money-of 1)
  ;; => {:amount 1M, :currency :eur}

  (dinero/money-of 1 :gbp)
  ;; => {:amount 1M, :currency :gbp}
#+end_src
For convenience, you can use the =with-currency= macro to bind the =*default-currency*= variable, so if that variable isn't configured in the configuration file, you don't need to specify the currency when creating a monetary amount:
#+begin_src clojure
  (dinero/with-currency :gbp
    (dinero/money-of 1))
  ;; => {:amount 1M, :currency :gbp}
#+end_src
If none the =amount= nor the =currency= is specified, it uses zero as the amount, and the default currency as the currency:
#+begin_src clojure
  (dinero/money-of)
  ;; => {:amount 0M, :currency :eur}
#+end_src
Although you can use either an integer, a floating-point number, a =BigDecimal= or a string as the =amount= argument, they are parsed and stored as =BigDecimals=:
#+begin_src clojure
  (dinero/money-of 1 :eur)
  ;; => {:amount 1M, :currency :eur}

  (dinero/money-of 1.23 :eur)
  ;; => {:amount 1.23M, :currency :eur}

  (dinero/money-of 1.23M :eur)
  ;; => {:amount 1.23M, :currency :eur}

  (dinero/money-of "1.23" :eur)
  ;; => {:amount 1.23M, :currency :eur}
#+end_src
/WARNING/:
#+begin_quote
Be aware that using floating-point numbers can lead to rounding errors in certain calculations, as Clojure reads them as =Doubles=, which are 64-bit IEEE 754 floating point numbers. This means you get double precision, with about 15-17 significant decimal digits of precision.

So, for accurate numerical computations, especially in financial applications, don't use floating-point numbers; use =BigDecimals= or =Strings= instead, as they will be parsed accurately.
#+begin_src clojure
  ;;; Not safe, as it uses floating point arithmetic, losing precision when parsing
  (dinero/money-of 0.123456789123456789123456789 :eur)
  ;; => {:amount 0.12345678912345678M, :currency :eur}

  ;;; Safe, as it uses BigDecimal or String
  (dinero/money-of 0.123456789123456789123456789M :eur)
  ;; => {:amount 0.123456789123456789123456789M, :currency :eur}
  (dinero/money-of "0.123456789123456789123456789" :eur)
  ;; => {:amount 0.123456789123456789123456789M, :currency :eur}
#+end_src
#+end_quote
*** Amount and currency
Given a monetary amount, you can get its amount and currency using the =get-amount= and =get-currency= functions:
#+begin_src clojure
  (let [money (dinero/money-of 1 :eur)]
    (dinero/get-amount money))
  ;; => 1M
  (let [money (dinero/money-of 1 :eur)]
    (dinero/get-currency money))
  ;; => :eur
#+end_src
*** Formatting
As already mentioned, amounts are stored internally with more decimal places than the smallest unit of the currency. Although this is crucial for accurate numerical computations, you might be interested in displaying amounts in a user-friendly format.

To display monetary amounts in a user-friendly format, you can use the =format= function. This function will convert the internal representation of the monetary amount into a string with a more readable format.

The =format= function accepts a map of configuration options as its second argument. The available options are:
- locale
- rounding-mode
- decimal-places
- symbol-style: could be =:symbol= or =:code= (=:symbol= is the default value)
For example:
#+begin_src clojure
  (let [m1 (dinero/money-of 1234.5678 :eur)
        germany java.util.Locale/GERMANY]
    (println (dinero/format m1 {:locale germany}))
    (println (dinero/format m1 {:locale germany :symbol-style :code}))
    (println (dinero/format m1 {:locale germany :rounding-mode :down :symbol-style :code}))
    (println (dinero/format m1 {:locale germany :rounding-mode :down :decimal-places 0 :symbol-style :code})))
  ;; 1.234,57 €
  ;; 1.234,57 EUR
  ;; 1.234,56 EUR
  ;; 1.234 EUR
#+end_src
You can also use the =format-with-pattern= function, which uses the given formatting pattern to format the monetary amount. This function also accepts a map of configuration options as its third argument, supporting these options:
- locale
- rounding-mode
For example:
#+begin_src clojure
  (let [m1 (dinero/money-of 1234.5678 :eur)
        germany java.util.Locale/GERMANY]
    (println (dinero/format-with-pattern m1 "#,##0.00 ¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0.00 ¤¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0.000 ¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0 ¤" {:locale germany}))
    (println (dinero/format-with-pattern m1 "#,##0 ¤" {:locale germany :rounding-mode :down})))
  ;; 1.234,57 €
  ;; 1.234,57 EUR
  ;; 1.234,568 €
  ;; 1.235 €
  ;; 1.234 €
#+end_src
*** Parsing
For now, this library only supports parsing strings that contain ISO 4217 currency symbols (like =€=) but does not support parsing strings with ISO 4217 currency codes (like =EUR=) or strings with non-ISO 4217 currency symbols or codes.

So you can use the =parse-containing-iso-4217-symbol= function to parse a string that contains an ISO 4217 currency symbol:
#+begin_src clojure
  (dinero/parse-containing-iso-4217-symbol "1.234,56 €" {:locale java.util.Locale/GERMANY})
  ;; => {:amount 1234.56M, :currency :eur}

  (dinero/parse-containing-iso-4217-symbol "£1,234.56" {:locale java.util.Locale/UK})
  ;; => {:amount 1234.56M, :currency :gbp}
#+end_src
But as mentioned, it doesn't support parsing strings with ISO 4217 currency codes (like =EUR=) or strings with non-ISO 4217 currency symbols or codes, throwing a =java.text.ParseException= exception in that case:
#+begin_src clojure
  (dinero/parse-containing-iso-4217-symbol "1.234,56 EUR" {:locale java.util.Locale/GERMANY})
  ;; java.text.ParseException
  ;; Unparseable number: "1.234,56 EUR"

  (dinero/parse-containing-iso-4217-symbol "1,23456789 ₿" {:locale java.util.Locale/GERMANY})
  ;; java.text.ParseException
  ;; Unparseable number: "1,23456789 ₿"

  (dinero/parse-containing-iso-4217-symbol "1,23456789 BTC" {:locale java.util.Locale/GERMANY})
  ;; java.text.ParseException
  ;; Unparseable number: "1,23456789 BTC"
#+end_src
The =parse-containing-iso-4217-symbol= function also throws a =java.text.ParseException= exception if the currency symbol is in the wrong position for the specified =locale=, or if the =locale= uses a different default currency:
#+begin_src clojure
  (dinero/parse-containing-iso-4217-symbol "€1.234,56" {:locale java.util.Locale/GERMANY})
  ;; java.text.ParseException
  ;; Unparseable number: "€1.234,56"

  (dinero/parse-containing-iso-4217-symbol "1.234,56 £" {:locale java.util.Locale/GERMANY})
  ;; java.text.ParseException
  ;; Unparseable number: "1.234,56 £"
#+end_src
** License
Copyright © 2024 Sergio Navarro

Distributed under the [[https://www.apache.org/licenses/LICENSE-2.0][Apache License, Version 2.0]].
